\section{变量，作用域与内存}
\subsection{原始值与引用值}

原始值就是最简单的数据，引用值是由多个值构成的对象。JavaScript 中，6个基本数据类型是原始值，变量按保存的是数据本身，其他数据类型保存的是引用。

与 Java/Python 不同的是，JavaScript 中的 String 类型是基本数据类型，是原始值，对应变量保存数据本身。

\subsubsection{动态属性}

对于引用值而言，可以随时添加，修改和删除其属性和方法。

\begin{JavaScript}
let person = new Object();
person.name = "Pionpill";
\end{JavaScript}

原始值不能拥有属性，尽管尝试添加属性不会报错(这样做没有意义)，但是调用时会报错。

注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是 \texttt{new} 关键字，则 JavaScript 会创建一个 \texttt{Object} 类型的实例，但其行为类似原始值。

\subsubsection{复制值}

JavaScript 对值复制的方法同 Java/Python 相同，原始值的复制将在内存中创建新的空间，而引用值的复制只是多加了一个引用(指向同一块内存区域)。

\subsubsection{传递参数}

ECMAScript 中所有函数的参数都是按值传递的。也就是说在函数中会创建一个新的局部变量，是原变量的复制。

下面通过一个例子说明引用值是如何按值传递的。

\begin{JavaScript}
function setName(obj) {
    obj.name = "Pionpill";
    obj = new Object();
    obj.name = "Brandon";
}

let person = new Object();
setName(person)
console.log(person.name);   // "Pionpill"
\end{JavaScript}

上述例子中，最终的输出是 \texttt{"Pionpill"} 而不是 \texttt{"Brandon"}，注意我们全局变量中的 \texttt{person} 和 传入函数的(局部变量) \texttt{person} 是两个不同的变量，他们都指向一个 \texttt{Object} 实例。在第二行，局部变量 \texttt{person} 修改了所指向的 \texttt{Object} 实例，创建 \texttt{name} 属性，值为 \texttt{"Pionpill"}。但在第3行，局部变量 \texttt{person} 创建了一个新的 \texttt{Object} 实例，不再指向原先的区域，因此此时再对局部变量 \texttt{person} 进行修改，不会影响到全局的 \texttt{person} 所指向的实例。

\fbox{
    \parbox{0.87\textwidth}{
        \begin{notice}
            上面示例代码仅因为要解释原理给出，实际作用中请不要随意在函数中改变属性或引用对象。
        \end{notice}
    }
}

\subsubsection{确定类型}

我们知道 \texttt{typeof} 操作符可以用来确定数据类型，但是在面向对象编程中，我们往往需要知道某一实例是什么类型的对象。这时候需要用到 \texttt{instanceof} 操作符。 

\begin{JavaScript}
person instanceof Object;   // person 是 Object 吗?
colors instanceof Array;    // colors 是 Array 吗?
\end{JavaScript}

\fbox{
    \parbox{0.87\textwidth}{
        \begin{notice}
            ECMA-262 规定，任何实现内部 \texttt{[call]} 方法的对象都应该在 \texttt{typeof} 检测时返回 \texttt{"function"}。但并不是所有浏览器都这样做。
        \end{notice}
    }
}

\subsection{上下文与作用域}

\textit{这个相信大姐都很熟，基础的就不说了}。

需要指出的是，所有通过 \texttt{var} 定义的全局变量很函数都会成为 \texttt{window} 对象的属性和方法。使用 \texttt{let} 和 \texttt{const} 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。

\subsubsection{作用域链增强}

执行上下文主要有全局上下文和函数上下文两种(\texttt{eval() 调用内部存在第三种上下文})，但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在实行代码后会被删除:
\begin{itemize}
    \item \texttt{try/catch} 语句的 \texttt{catch} 块
    \item \texttt{with} 语句
\end{itemize}